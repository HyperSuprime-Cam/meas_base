// -*- lsst-c++ -*-

namespace lsst { namespace meas { namespace base {
/**
@mainpage lsst::meas::base;  redesigned support for measurement tasks and algorithm plugins

@section measBaseIntroduction Introduction to meas_base
The meas_base package is the new home of the source measurement framework, which was formerly part of
meas_algorithms.

The source measurement framework is a set of Python modules which allow measurements to be performed on
calibrated exposures. The framework assumes that a detection catalog has been prepared to identify the
objects to be measured.  The detection catalog may have been produced with a detection pass on the exposure
itself, but it might also be produced from other exposures, stacks, or even multiple exposures.
Deblending may or may not have been performed during the creation of the detection catalog.

The framework steps through the detection catalog and performs a set of measurements, object by object,
supplying each measurement plugin with the exposure and catalog information needed for its measurement.
The measurement results (values, errors, and flags) are then placed in an output catalog.

The measurement framework includes the following features:
 
 - SingleFrameMeasurementTask, a subtask that measures after detection and deblending on the same frame.
 - ForcedCcdTask and ForcedCoaddTask, a command-line task for performing constrained measurements on a
   frame other than the detection frame.  These delegate most of their work to their base class,
   ForcedMeasurementTask.
 - (coming soon) MultiFitTask, a command-line task for performing measurements on many exposures
   simultaneously.
 - Python Plugin base classes (SingleFramePlugin, ForcedPlugin, MultiFitPlugin) for each of the above, which
   define the API for measurements that will be run by the tasks, along with a single registry mechanism for
   making them available to the Tasks via config.
 - Helper code to reduce boilerplate, standardize outputs, and make algorithm code easy to reuse when
   implementing new measurement algorithms.

@section measBaseImplementingNew Implementing New Plugins and Algorithms

@subsection measBasePlugins Pure Python: The Plugin Interface

The "Plugin" interfaces used directly by the measurement tasks are defined completely in Python, and are
rooted in the abstract base classes sfm.SingleFramePlugin and forcedImage.ForcedPlugin.  Creating a new
Plugin is quite straightforward.

For a SingleFramePlugin:
 - Subclass sfm.SingleFramePlugin (a forcedPlugin must be defined separately, as it has different
   method signatures.
 - Implement an @c %__init__ method with the same signature as the base class, in which fields saved by the
   the Plugin should be added to the schema passed to @c %__init__, with keys saved as instance attributes
   for future use.
 - Reimplement @c measure() to perform the actual measurement and save the result in the measRecord argument.
 - Reimplement @c fail() unless the Plugin cannot fail (except for environment errors).
 - Reimplement @c measureN() if the Plugin supports measuring multiple sources simultaneously.
 - Register the Plugin with the config mechanism by calling e.g. @c SingleFramePlugin.registry.register()
   at module scope (so the registration happens at import-time).

For a ForcedPlugin
 - Subclass forceImage.ForcedPlugin
 - Implement an @c %__init__ method with the same signature as the base class, in which fields saved by the
   the Plugin should be added to the outputSchema of the schemaMapper passed to @c %__init__,
   with keys saved as instance attributes for future use.
 - Reimplement @c measure() to perform the actual measurement and save the result in the measRecord argument.
   Note that the refRecord and refWcs are available during the measurement if needed.
 - Reimplement @c fail() unless the Plugin cannot fail (except for environment errors).
 - Reimplement @c measureN() if the Plugin supports measuring multiple sources simultaneously.
 - Register the Plugin with the config mechanism by calling e.g. @c ForcedPlugin.registry.register()
   at module scope (so the registration happens at import-time).

Defining a Plugin directly has several disadvantages, however.  Using this approach, it is difficult to share
code between single-frame and forced plugins, and the definition and filling of fields often involves a lot
of boilerplate.  Perhaps more importantly, the Plugin interface is difficult to utilize outside of typical
pipeline usage; when one simply wants to apply a measurement to a postage stamp image, for instance, we'd
like to avoid the overhead of constructing a SourceCatalog to store the outputs.  Finally, most measurement
algorithms should generally be implemented in C++ for performance reasons, and inheriting from an existing
pure-Python class via Swig is difficult at best (it may in fact be impossible).

@subsection measBaseAlgorithms Introducing Algorithms

Instead of implementing Plugins directly, then, we generally advise that new Plugins be created by defining
what we will refer to as an "Algorithm" class in C++ (in the future, Algorithm classes may also be created
in Python, but this is not yet supported).  Algorithm is not a polymorphic class hierarchy; it is perhaps
more like a C++ <a href="http://en.cppreference.com/w/cpp/concept">Concept </a> .  If a C++ class meets the
Algorithm requirements (see below), one can create
a Plugin (a subclass of sfm.WrappedSingleFramePlugin or sfm.WrappedForcedPlugin) automatically.  The Algorithm
interface is designed to be easy-to-use outside of the measurement framework, while still consistent enough
to allow Plugins that delegate to the Algorithm to be machine-generated.  Once can also define both a
SingleFramePlugin and a ForcedPlugin that delegate to the same Algorithm method in most cases.

The best way to learn how to write a new Algorithm
is by example, and for this purpose two of the Algorithms defined in meas_base have been supplied with
additional documentation intended to allow them to be used as tutorials.  PsfFluxAlgorithm is an example
of an extremely simple algorithm - it measures only one standard quantity, has few configuration options,
and has very standard inputs.  SdssShapeAlgorithm provides a much more complex example.

@subsection measBaseAlgorithmConcept The Algorithm Concept

While much more documentation can be found in the examples and in the auxiliary classes (see
@ref measBaseResults in particular), here is a summary of the Algorithm requirements:

 - a static apply() method that performs the actual measurement, or delegates to one that does.  It should
   have the signature @code Result apply(Exposure<float> const &, Input const &, Control const &) @endcode
   @c Result, @c Inputs, and @c Control are class typedefs described below.  The method may be
   templated on the type of exposure, but only the @c Exposure<float> instantiation will be called.  It is
   recommended (but not required) that the Control argument have a default value.

 - an @c Input typedef to one of AlgorithmInput1, AlgorithmInput2, or AlgorithmInput3, or a custom class
   that has a constructor and makeVector() method with the same signature as those classes.

 - a @c Result typedef to one of @ref measBaseResultTemplates that defines the type returned by apply().

 - a @c ResultMapper typedef to one of @ref measBaseResultMapperTemplates that defines how to transfer the
   @c Result struct to an output record.

 - a @c Control typedef to a C++ "control object" (a struct that uses the LSST_CONFIG_FIELD macro;
   see lsst.pex.config.wrap.makeConfigClass for more information).

 - a static makeResultMapper() method, responsible for creating a ResultMapper instance that will be used
   to transfer Result outputs to output records.  Its signature must be
   @code ResultMapper makeResultMapper(afw::table::Schema &, std::string &, Control const &) @endcode

 - a FlagBits enum with a value for each flag the measurement can set (see FlagsComponent), as well as
   a final N_FLAGS enum value that sets the total number of flags.

 - a static getFlagDefinitions() method that returns a const reference to,
   @c boost::array<FlagDef,N_FLAGS>, describing the flags in greater detail.

 - Optional: if a measureN() Plugin method is to be provided, an applyN() method with signature
   @code std::vector<Result> applyN(Exposure<float> const &, std::vector<Input> const &, Control const &)
   @endcode

@subsection measBaseAlgorithmSwig Swig Interfaces for Algorithms

In addition, Algorithm classes should generally be wrapped using one of the @c %%wrapMeasurementAlgorithmN
Swig macros (where @c N is one of 1, 2, 3, or 4, matching the numbers in the Result and ResultMapper
templates). This should be invoked after %%including the C++ header file that defines the algorithm.
The signature for these macros is
@code %wrapMeasurementAlgorithm[N](NAMESPACE, ALGORITHM, CONTROL, INPUT, T1, ...) @endcode
where @c NAMESPACE is the namespace the algorithm is defined in, ALGORITHM is the unqualified name of the
algorithm class, @c CONTROL and @c INPUT are the namespace-unqualified classes referred to by the class
typedefs of the same name, and @c T1, ... are the list of Component objects used to instantiate the Result
template.
This macro will handle @c %%template instantiation of the @c Result and @c ResultMapper classes and their
corresponding @c FlagComponent and @c FlagComponentMapper classes, and install Python class attributes that
mimic the C++ typedefs in the Algorithm class.  These macros do not instantiate templated @c apply() or
@c applyN() methods in Swig, however, and this must be done manually if those methods are templated in C++.

Finally, to actually create a Plugin class from the Swigged Algorithm, one should call
sfm.WrappedSingleFramePlugin.generate() or forcedImage.WrappedForcedPlugin.generate() at module scope
(i.e. so it is invoked at module-import time) to create the Plugin classes themselves and register them with
the config mechanism.

@section measBaseErrorHandling Error Handling

When a Plugin (or the Algorithm it delegates to) raises any exception, the Task calling it will catch the
exception, and call the fail() method of the Plugin, which should cause the plugin to set one or more
flags in the output record.  If the exception is MeasurementError (note that in Python, this
will be raised as lsst.pex.exceptions.LsstCppException; see @ref secExcPython), the Task will pass this
exception back to the fail() method, as MeasurementError contains additional Plugin-specific information
indicating the kind of failure.  For most other exceptions, the Task will log the exception message
as a warning, and pass None as the exception to fail().  In this case, the Plugin should just set the
primary failure flag.  This is handled automatically by the FlagsComponentMapoper in Algorithm-based
Plugins.
Certain exceptions (in particular, out-of-memory errors) are considered fatal and will always be propagated
up out of the Task.

Plugin/Algorithm code should endeavor to only throw MeasurementError for known failure modes, unless the
problem is in the data and can always be fixed there before the measurement framework is invoked.  In other
words, we want warnings to appear in the logs only when there's a bug, whether that's in the processing
before the measurement framework or in a particular Plugin/Algorithm not knowing and documenting its own
failure modes.  This means that Plugin/Algorithm implementations should generally have a global try/catch
block that re-throwns lower-level exceptions corresponding to known failure modes as MeasurementErrors.

*/
}}} // namespace lsst::meas::base
