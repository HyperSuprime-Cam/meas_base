// -*- lsst-c++ -*-

namespace lsst { namespace meas { namespace base {
/**
@mainpage lsst::meas::base;  redesigned support for measurement tasks and algorithm plugins

@section measBaseIntroduction Introduction to meas_base
The meas_base package is the new home of the source measurement framework, which was formerly part of
meas_algorithms.

The source measurement framework is a set of Python modules which allow measurements to be performed on
calibrated exposures. The framework assumes that a detection catalog has been prepared to identify the
objects to be measured.  The detection catalog may have been produced with a detection pass on the exposure
itself, but it might also be produced from other exposures, stacks, or even multiple exposures.
Deblending may or may not have been performed during the creation of the detection catalog.

The framework steps through the detection catalog and performs a set of measurements, object by object,
supplying each measurement plugin with the exposure and catalog information needed for its measurement.
The measurement results (values, errors, and flags) are then placed in an output catalog.

The measurement framework includes the following features:

 - SingleFrameMeasurementTask, a subtask that measures after detection and deblending on the same frame
   (see measBaseSFM).
 - Several tasks for forced photometry (see measBaseForcedPhot).
 - Python Plugin base classes (SingleFramePlugin, ForcedPlugin) for single-frame and forced measurement.
   define the API for measurements that will be run by the tasks, along with a single registry mechanism for
   making them available to the Tasks via config.
 - Helper code to reduce boilerplate, standardize outputs, and make algorithm code easy to reuse when
   implementing new measurement algorithms.

@section measBaseSFM Single-Frame Measurement

The single frame measurement framework is used when all the information about the sources to be measured
comes from a single image, and hence those sources are detected (and possibly) deblended on that image
before measurement.  This image may be a coadd of other images, or even a difference of images - from
the perspective of the measurement framework there is essentially no difference between these cases (though
there may be important differences for particular measurement algorithms).

The high-level algorithm for single-frame measurement is:

 - The SingleFrameMeasurementTask is initialized (see also SingleFrameMeasurementTask.__init__).  This
   initializes all the configured algorithms, creating a schema for the outputs in the process.  After
   this stage, the schema cannot be modified and algorithm configuration can not longer be modified.

 - SingleFrameMeasurementTask.run is called on each image to be processed, with a SourceCatalog containing
   all the sources to be measured.  These sources must have Footprints (generated by
   lsst.meas.algorithms.SourceDetectionTask), and a schema that matches that constructed by the previous
   step.  The fields added to the schema during initialization will then be filled in by the measurement
   framework.

    * Before measuring any sources, the measurement framework replaces all sources in the catalog with
      noise (see NoiseReplacer), using the Footprints attached to the SourceCatalog to define their
      boundaries.

    * We then loop over all "parent" sources in the catalog - both those that were not blended, and those
      that represent the pre-deblend combined state of blends.  For each parent, we loop again over all its
      children (if any), and for each of these, we re-insert the child source into the image (which, recall,
      currently contains only noise), call SingleFramePlugin.measure() on each of the plugins, and then
      replace the child source with noise again.  We the insert the parent source, and call
      SingleFramePlugin.measure() on all of the plugins.  Before replacing the parent with noise, we then
      call SingleFramePlugin.measureN() twice: once with the list of all children, and once with a
      single-element list containing just the parent.  This ensures that each source (parent or child)
      is measured with both measure() and measureN(), with the former preceeding the latter.

Because measurement plugin algorithms are often dependent on each other (in particular, most measurements
require a centroid as an input), they must be run in a particular order, and we need a mechanism for passing
information between them.  The order is defined by the 'executionOrder' config parameter, which is defined
in the BasePluginConfig class, and hence present for every plugin.  Generally, these will remain at their
default values; it is the responsibility of a plugin implementor to ensure the default for that plugin
is appropriate relative to any plugins it depends on.  See BasePluginConfig.executionOrder for some
guidelines.

The mechanism for passing information between plugins is SourceTable's "slot" system (see
afw::table::SlotDefinition), in which particular
measurements are given one of several predefined aliases (e.g. "slot_Centroid" -> "base_SdssCentroid"),
which are used to implement getters on SourceRecord (e.g. "getCentroid").  The measurement framework's
configuration defines which measurements are assigned to each slot, and these slot measurements are
available to other plugins as soon as the plugin whose outputs are assigned to the slot are run.

All this means that algorithms that need a centroid as input should simply call getCentroid() on the
SourceRecord they're provided, and ensure that their executionOrder is higher than that of centroid
algorithms.  Similarly, algorithms that want a shape should simply call SourceRecord::getShape().  Things
are a bit trickier for centroid algorithms, which often need to be given an approximate centroid as an
input; these should be prepared to look at the Peaks attached to the SourceRecord's Footprint as an initial
value, as the slot centroid may not yet be valid.  For wrapped C++ Algorithms (see measBaseAlgorithmConcept),
this is handled automatically.

@section measBaseForcedPhot Forced Photometry

In forced photometry, an external "reference" catalog is used to constrain measurements on an image.  While
parts of the forced photometry framework could be with a reference catalog from virtually any source, a
complete system for loading the reference catalogs that correspond to the region of sky being measured
is only available when measurements from a coadd are used as the reference.

While essentially any measurement plugin can be run in forced mode, typically only photometric measurements
are scientifically useful (though centroids and shapes may be useful for quality metrics).  In fact, in
forced mode we typically configure pseudo-measurements to provide the shape and centroid slots, and it is
these - not anything special about the forced measurement framework that constrains measurements.  In
particular, we generally use the ForcedTransformedCentroid and ForcedTransformedShape to provide the centroid
and shape slots.  Rather than measure the centroid and shape on the image, these simply transform the
centroid and shape slots from the reference catalog to the appropriate coordinate system.  This ensures that
measurements that use these slots to obtain positions and ellipses use the same quantities used in generating
the reference catalog.

The core of the forced measurement framework is ForcedMeasurementTask and ForcedPlugin, which broadly
parallel SingleFrameMeasurementTask and SingleFramePlugin.  The high-level algorithm is essentially the same,
but with the SourceCatalog to be measured generated by ForcedMeasurementTask.generateSources() from the
reference catalog, rather than provided by the user after running detection.  The corresponding reference
source and the Wcs objects that define the mapping between reference and measurement coordinate systems
are also provided to each plugin.

The fact that the sources to be measured are generated from the reference catalog means that the Footprints
attached to these sources must be transformed from the reference coordinate system to the measurement
coordinate system, and at present that operation turns HeavyFootprints into regular Footprints.
HeavyFootprints for child sources are necessary in order to correctly replace neighboring children of the
same parent with noise prior to measurement (see NoiseReplacer), and the lack of these means that deblended
measurement in forced photometry is essentially broken, except for plugins that implement measureN() and
can hence correctly measure all children simultaneously without having to replace them with noise
individually.

In addition to the ForcedMeasurementTask subtask and its plugins, the forced measurement framework also
contains a pair of command-line driver tasks, ForcedPhotCcdTask and ForcedPhotCoaddTask.  These run
forced measurement on CCD-level images and coadd patch images, respectively, using the outputs of a
previous single-frame measurement run on coadds as the reference catalog in both cases.  These delegate
the work of loading (and as necessary, filtering and merging) the appropriate reference catalog for the
measurement image to a "references" subtask.  The interface for the reference subtask is defined by
BaseReferencesTask, with the concrete implementation that utilizes coadd processing outputs in
CoaddSrcReferencesTask.  In general, to use a reference catalog from another source, one should
implement a new references subtask, and reuse ForcedPhotCcdTask and/or ForcedPhotCoaddTask.  It should
only be necessary to replace these and call ForcedMeasurementTask directly if you need to run forced
photometry on data that isn't organized by the Butler or doesn't correspond to CCD- or patch-level images.

@section measBaseImplementingNew Implementing New Plugins and Algorithms

@subsection measBasePlugins Pure Python: The Plugin Interface

The "Plugin" interfaces used directly by the measurement tasks are defined completely in Python, and are
rooted in the abstract base classes sfm.SingleFramePlugin and forcedImage.ForcedPlugin.  Creating a new
Plugin is quite straightforward.

For a SingleFramePlugin:
 - Subclass sfm.SingleFramePlugin (a ForcedPlugin must be defined separately, as it has different
   method signatures).
 - Implement an @c %__init__ method with the same signature as the base class, in which fields saved by the
   the Plugin should be added to the schema passed to @c %__init__, with keys saved as instance attributes
   for future use.
 - Reimplement @c measure() to perform the actual measurement and save the result in the measRecord argument.
 - Reimplement @c fail() unless the Plugin cannot fail (except for environment errors).
 - Reimplement @c measureN() if the Plugin supports measuring multiple sources simultaneously.
 - Register the Plugin with the config mechanism by calling e.g. @c SingleFramePlugin.registry.register()
   at module scope (so the registration happens at import-time).

For a ForcedPlugin
 - Subclass forcedMeasurement.ForcedPlugin
 - Implement an @c %__init__ method with the same signature as the base class, in which fields saved by the
   the Plugin should be added to the outputSchema of the schemaMapper passed to @c %__init__,
   with keys saved as instance attributes for future use.
 - Reimplement @c measure() to perform the actual measurement and save the result in the measRecord argument.
   Note that the refRecord and refWcs are available during the measurement if needed.
 - Reimplement @c fail() unless the Plugin cannot fail (except for environment errors).
 - Reimplement @c measureN() if the Plugin supports measuring multiple sources simultaneously.
 - Register the Plugin with the config mechanism by calling e.g. @c ForcedPlugin.registry.register()
   at module scope (so the registration happens at import-time).

Defining a Plugin directly has several disadvantages, however.  Using this approach, it is difficult to share
code between single-frame and forced plugins, and the definition and filling of fields often involves a lot
of boilerplate.  Perhaps more importantly, the Plugin interface is difficult to utilize outside of typical
pipeline usage; when one simply wants to apply a measurement to a postage stamp image, for instance, we'd
like to avoid the overhead of constructing a SourceCatalog to store the outputs.  Finally, most measurement
algorithms should generally be implemented in C++ for performance reasons, and inheriting from an existing
pure-Python class via Swig is difficult at best (it may in fact be impossible).

@subsection measBaseAlgorithms Introducing Algorithms

Instead of implementing Plugins directly, then, we generally advise that new Plugins be created by defining
what we will refer to as an "Algorithm" class in C++ (in the future, Algorithm classes may also be created
in Python, but this is not yet supported).  Algorithm is not a polymorphic class hierarchy; it is perhaps
more like a C++ <a href="http://en.cppreference.com/w/cpp/concept">Concept </a> .  If a C++ class meets the
Algorithm requirements (see below), one can create
a Plugin (a subclass of sfm.WrappedSingleFramePlugin or sfm.WrappedForcedPlugin) automatically.  The Algorithm
interface is designed to be easy-to-use outside of the measurement framework, while still consistent enough
to allow Plugins that delegate to the Algorithm to be machine-generated.  Once can also define both a
SingleFramePlugin and a ForcedPlugin that delegate to the same Algorithm method in most cases.

The best way to learn how to write a new Algorithm
is by example, and for this purpose two of the Algorithms defined in meas_base have been supplied with
additional documentation intended to allow them to be used as tutorials.  PsfFluxAlgorithm is an example
of an extremely simple algorithm - it measures only one standard quantity, has few configuration options,
and has very standard inputs.  SdssShapeAlgorithm provides a much more complex example.

@subsection measBaseAlgorithmConcept The Algorithm Concept

While much more documentation can be found in the examples and in the auxiliary classes (see
@ref measBaseResults in particular), here is a summary of the Algorithm requirements:

 - a static apply() method that performs the actual measurement, or delegates to one that does.  It should
   have the signature @code Result apply(Exposure<float> const &, Input const &, Control const &) @endcode
   @c Result, @c Inputs, and @c Control are class typedefs described below.  The method may be
   templated on the type of exposure, but only the @c Exposure<float> instantiation will be called.  It is
   recommended (but not required) that the Control argument have a default value.

 - an @c Input typedef to one of AlgorithmInput1, AlgorithmInput2, or AlgorithmInput3, or a custom class
   that has a constructor and makeVector() method with the same signature as those classes.

 - a @c Result typedef to one of @ref measBaseResultTemplates that defines the type returned by apply().

 - a @c ResultMapper typedef to one of @ref measBaseResultMapperTemplates that defines how to transfer the
   @c Result struct to an output record.

 - a @c Control typedef to a C++ "control object" (a struct that uses the LSST_CONFIG_FIELD macro;
   see lsst.pex.config.wrap.makeConfigClass for more information).

 - a static makeResultMapper() method, responsible for creating a ResultMapper instance that will be used
   to transfer Result outputs to output records.  Its signature must be
   @code ResultMapper makeResultMapper(afw::table::Schema &, std::string &, Control const &) @endcode

 - a FlagBits enum with a value for each flag the measurement can set (see FlagsComponent), as well as
   a final N_FLAGS enum value that sets the total number of flags.

 - a static getFlagDefinitions() method that returns a const reference to,
   @c boost::array<FlagDef,N_FLAGS>, describing the flags in greater detail.

 - Optional: if a measureN() Plugin method is to be provided, an applyN() method with signature
   @code std::vector<Result> applyN(Exposure<float> const &, std::vector<Input> const &, Control const &)
   @endcode

@subsection measBaseAlgorithmSwig Swig Interfaces for Algorithms

In addition, Algorithm classes should generally be wrapped using one of the @c %%wrapMeasurementAlgorithmN
Swig macros (where @c N is one of 1, 2, 3, or 4, matching the numbers in the Result and ResultMapper
templates). This should be invoked after %%including the C++ header file that defines the algorithm.
The signature for these macros is
@code %wrapMeasurementAlgorithm[N](NAMESPACE, ALGORITHM, CONTROL, INPUT, T1, ...) @endcode
where @c NAMESPACE is the namespace the algorithm is defined in, ALGORITHM is the unqualified name of the
algorithm class, @c CONTROL and @c INPUT are the namespace-unqualified classes referred to by the class
typedefs of the same name, and @c T1, ... are the list of Component objects used to instantiate the Result
template.
This macro will handle @c %%template instantiation of the @c Result and @c ResultMapper classes and their
corresponding @c FlagComponent and @c FlagComponentMapper classes, and install Python class attributes that
mimic the C++ typedefs in the Algorithm class.  These macros do not instantiate templated @c apply() or
@c applyN() methods in Swig, however, and this must be done manually if those methods are templated in C++.

Finally, to actually create a Plugin class from the Swigged Algorithm, one should call
sfm.WrappedSingleFramePlugin.generate() or forcedImage.WrappedForcedPlugin.generate() at module scope
(i.e. so it is invoked at module-import time) to create the Plugin classes themselves and register them with
the config mechanism.

@section measBaseErrorHandling Error Handling

When a Plugin (or the Algorithm it delegates to) raises any exception, the Task calling it will catch the
exception, and call the fail() method of the Plugin, which should cause the plugin to set one or more
flags in the output record.  If the exception is MeasurementError, the Task will pass this
exception back to the fail() method, as MeasurementError contains additional Plugin-specific information
indicating the kind of failure.  For most other exceptions, the Task will log the exception message
as a warning, and pass None as the exception to fail().  In this case, the Plugin should just set the
primary failure flag.  This is handled automatically by the FlagsComponentMapoper in Algorithm-based
Plugins.
Certain exceptions (in particular, out-of-memory errors) are considered fatal and will always be propagated
up out of the Task.

Plugin/Algorithm code should endeavor to only throw MeasurementError for known failure modes, unless the
problem is in the data and can always be fixed there before the measurement framework is invoked.  In other
words, we want warnings to appear in the logs only when there's a bug, whether that's in the processing
before the measurement framework or in a particular Plugin/Algorithm not knowing and documenting its own
failure modes.  This means that Plugin/Algorithm implementations should generally have a global try/catch
block that re-throwns lower-level exceptions corresponding to known failure modes as MeasurementErrors.

*/
}}} // namespace lsst::meas::base
